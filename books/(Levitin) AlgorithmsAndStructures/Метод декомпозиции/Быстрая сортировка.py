"""
Quicksort:
Элементы массива разделяются в соответствии с их значениями.
A[0], A[1], ..., A[n-1] переставляются так, чтобы
    A[0], ..., A[s-1] - элементы меньше опорного
    A[s] - опорный
    A[s+1], ..., A[n-1] - элементы больше опорного
После такого разбиения элемент A[s] находится в окончательной позиции
в отсортированного массиве
Далее независимо сортируются два подмассива A[0...s-1] и A[s+1, ..., n-1]

Partition:
- выбирается pivot - опорный элемент (относительно него будет происходит разбиение)
- два прохода по массиву одновременно: слева направо (i) и справа налево (j)
- первый проход пропускает элементы, меньше опорного,
и останавливается, встретим элемент, >= опорного
- второй проход пропускает элементы, большие опорного,
и останавливается, встретив элемент, <= опорного
- анализируются 3 различные ситуации:
-- i < j ||  тогда происходит обмен Array[i] и Array[j]
-- i > j ||  тогда происходит обмен pivot с Array[j]
-- i = j ||  тогда pivot = Array[i] = Array[j]
(Можно этот случай объединить с ситуацией, когда i>j (получим i>=j))
"""

def quicksort(Array, left_i = None, right_j = None):
    if left_i == None:
        left_i, right_j = 0, len(Array)-1
    if left_i < right_j:
        s = partition(Array, left_i, right_j)
        quicksort(Array, left_i, s-1)
        quicksort(Array, s+1, right_j)


def partition(Array, left_i, right_j):
    pivot = Array[left_i]
    i, j = left_i+1, right_j
    while i <= j:
        while Array[i] < pivot:
            i += 1
        while Array[j] > pivot:
            j -= 1
        Array[i], Array[j] = Array[j], Array[i]

    # отмена последнего обмена
    Array[i], Array[j] = Array[j], Array[i]
    # перемещение опорного элемента на нужную позицию
    Array[left_i], Array[j] = Array[j], Array[left_i]
    # возвращение индекса опорного элемента
    return j

example = [100, 0.23, 10, -100292, 0.10101, 5, 3, 1, 1209, 9, 8, 2, 4, 7]
print(f'example = {example}')
quicksort(example)
print(f'after quicksort: {example}')

# Наилучший случай реализуется тогда, когда s находится
# примерно посередине
# Наихудший случай - когда s в начале или в конце
# ------------
# Лучший случай - Teta(n*log_2(n))
# Худший случай - когда массив отсортирован (Teta(n^2))
# В среднем случае для случайных массивов данный алгоритм работает лучше,
# чем сортировка слиянием. Для улучшения можно производить разбиение на основе других методов
# (медиана трех элементов, например)
