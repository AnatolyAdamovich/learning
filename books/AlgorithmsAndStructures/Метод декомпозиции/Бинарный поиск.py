"""
Бинарный поиск пригоден для отсортированных массивов
Искомый ключ *K* сравнивается с средним элементов массива A[center_index]
Если они равны, то алгоритм прекращает работу.
В ином случае операция рекурсивно повторяется для:
- первой половины массива, если K < A[center_index]
- второй половины массива, если K > A[center_index]
"""

def binary_search(Array, K):
    left, right = 0, len(Array)-1
    while left <= right:
        center_index = (right + left) // 2
        if K == Array[center_index]:
            return center_index
        elif K > Array[center_index]:
            left = center_index+1
        else:
            right = center_index-1
    return -1

example = [i**2 for i in range(15)]
print(f'example = {example}')
print(f'index of 121 = {binary_search(example, 121)}')
print(f'index of 9 = {binary_search(example, 9)}')
print(f'index of 1000 = {binary_search(example, 1000)}')

# Основная базовая операция - сравнение ключа K с элементами массива
# Количество сравнений зависит не только от размера входных данных,
# но и от конкретного содержания массива
# => задача относится к классу количественно-параметрических
# по функции трудоемкости
#
# Бинарный поиск хорош тем, что его временная сложность
# в худшем (и близко к среднему) случае составляет всего Teta(log_2(n))
#
# Бинарный поиск - это весьма нетеипичный случай метода декомпозиции
# Бинарный поиск больше соответствует *методу деления пополам*,
# который будет рассмотрен далее