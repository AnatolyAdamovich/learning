"""
Задача:
Есть строка длиной n  (текст)
и текст длины m (шаблон)
Требуется найти в тексте подстроку, соответствующую шаблону

Можно возвращать i - индекс крайнего слева элемента
первой соответствующей шаблону строки
Можно продолжить поиск до полной проверки текста и вернуть все индексы всех подстрок

StringMatch:
выровнять шаблон с началом текста
сравнивать соответствующие пары символов слева направо
до тех пор, пока символы во всех m парах не будут равны,
либо пока не встретится пара разных символов
в этом случае сместиться шаблону на одну позицию вправо и начать новое сравнение
(смещение вправо происходит до n-m-1 символа)
"""

def StringMatch(text, pattern):
    n = len(text)
    m = len(pattern)
    for i in range(0, n-m):
        k = 0
        while (k < m) and (text[k+i] == pattern[k]):
            k += 1
        if k == m:
            return i
    return -1

example = "NOBODY NOTICED HIM"
patt = "NOT"
print(example[StringMatch(example, patt):StringMatch(example, patt) + len(patt)])


# Худший случай - выполнение m сравнений перед сдвигом шаблона в каждой из n-m-1 попыток
# Teta(m * (n-m-1)) = Teta(n*m)
# В случае типичного поиска можно ожидать, что
# количество сравнений в каждой из попыток будет
# в разы меньше, чем m
#
# При поиске в случайных текстах время работы
# оказывается линейной (Teta(n+m)=Teta(n))